package org.example.thread;

/*
* 本文描述 juc AQS 相关的内容。
*
* 1. 解决什么问题
*
* 不论是线程的互斥(锁)、还是线程之间的协调(条件变量等)，底层本质都是线程的 阻塞-唤醒 机制。
*
* 比如我们知道 linux 系统下的 futex 系统调用，就是一个线程的 等待-唤醒 机制，很多语言都使用了该系统调用
* 实现线程的 阻塞-唤醒 机制，比如 java 的 LockSupport.park() 和 LockSupport.unpark() 方法底层就是
* 通过 futex 实现的。
*
* AQS(AbstractQueuedSynchronizer) 的目的就是提供一个统一的线程 阻塞-唤醒 的框架，封装复杂的细节。这样基于
* 此框架就可以很方便的实现其他的一些线程互斥、协调机制。
*
* 2. 实现原理
*
* 本质来说，就是有个资源，当不满足占用条件的时候，线程就阻塞，当满足条件的时候，唤醒阻塞线程。
*
* 而这个资源绝大多数场景下，其实就是个 int 变量，这个在 AQS 中定义为 state。
*
* 阻塞的线程保存在一个队列中，这个队列就是 wait queue，在 AQS 中通过 head(头节点) 和 tail(尾节点)表示。
*
* 这里的难点是什么呢？
*
* 难点就是 release() 这个行为是可能发生在任何时机的，如果处理不当，就有可能导致某个线程永久阻塞。
* 那么 AQS 是如何解决这个问题的呢？
*
* 我们重点看看 acquire() 的流程(我们只关注重点内容)：
* - 首先调用 tryAcquire() 尝试占有资源。
* - 如果失败，则会创建节点并加入到 wait queue 中。
* 这一步就需要特别注意了，release() 是可能发生在节点加入 wait queue 之前的，如果这里加入 wait queue，
* 然后直接 park() 当前线程就可能永久阻塞。
*
* 所在在加入到 wait queue 之后，如果当前节点是第一个节点(实际上是 head.next，head 为当前占有锁的节点)，
* 则会再次 tryAcquire() 下。
*
* 如果还是失败，是不是就可以直接 park() 了？
* 还是不行，因为 release() 不知道要不要去唤醒线程，所以还需要设置个标记，告诉 release() 如果这个标记设置了
* 那就去唤醒对应的阻塞线程。
*
* 在 AQS 中，这个标记维护在 node 中，当 node.status == waiting， 表示 node 对应的线程要阻塞/已经阻塞了。
* 设置好标记之后，还需要再进行一次 tryAcquire()，因为 release() 可能发生在设置标记之前。
*
* 如果还是 acquire() 失败，则当前线程会真正进入 park() 流程。
*
* 不过这里还需要注意个问题，假设在调用 park() 之前，发生了 release()，release 发现设置了 waiting 标记，那就会
* 调用 unpark() 方法唤醒线程，但是实际上线程还没有阻塞。如果线程在 release 调用 unpark 之后再调用 park，会不会
* 永久陷入阻塞呢？
*
* 其实不会，unpark、park 底层基于 futex 实现，执行 unpark 操作后，futex 对应的变量会更改为 1，在执行 park 的时候，
* 如果变量为 1，则置为0 并返回，不会进入后续的阻塞流程。
*
* 除了 wait queue 外，AQS 还提供了条件队列即 ConditionObject 类型，对于一个 Node，如果需要在某个条件等待，就需要释放锁
* 并加入到 ConditionObject 对应的队列中，比如条件变量的 cond.await() 方法。另外，还可能从条件队列中移除，然后加入到 wait queue
* 重新占有锁，比如条件变量的 cond.signal() 方法。
*
* 因为只有持有锁才可以 操作 ConditionObject 队列，所以对于 ConditionObject 的操作无需额外的并发安全手段。
*
* 2.1 wait queue 操作如何保证并发安全
*
* 2.1.1 写操作
*
* 2.1.1.1 尾部插入节点
*
* 可能同时存在多个线程获取不到资源，然后需要插入到 wait queue 队列中，因此需要保证并发安全。
* 通过 CAS 实现。
*
* 2.1.1.2 更换头节点
*
* 当 first 节点获取到锁以后，就需要将 head 成员设置为当前节点。因为只有 first 节点才可以更新 head，而且 head 是个引用，
* 其写操作就是原子的，因此无需额外的并发安全机制。
*
* 2.1.2 读操作
*
*
*
* 3. 注意事项
*
* 平常开发中，只要能熟练掌握常见的并发工具就足够了。AQS 了解即可。
*
* */
public class AQS {
}
